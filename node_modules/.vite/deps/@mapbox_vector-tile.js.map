{
  "version": 3,
  "sources": ["../../@mapbox/vector-tile/node_modules/@mapbox/point-geometry/index.js", "../../@mapbox/vector-tile/index.js"],
  "sourcesContent": ["/**\n * A standalone point geometry with useful accessor, comparison, and\n * modification methods.\n *\n * @class\n * @param {number} x the x-coordinate. This could be longitude or screen pixels, or any other sort of unit.\n * @param {number} y the y-coordinate. This could be latitude or screen pixels, or any other sort of unit.\n *\n * @example\n * const point = new Point(-77, 38);\n */\nexport default function Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype = {\n    /**\n     * Clone this point, returning a new point that can be modified\n     * without affecting the old one.\n     * @return {Point} the clone\n     */\n    clone() { return new Point(this.x, this.y); },\n\n    /**\n     * Add this point's x & y coordinates to another point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    add(p) { return this.clone()._add(p); },\n\n    /**\n     * Subtract this point's x & y coordinates to from point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    sub(p) { return this.clone()._sub(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    multByPoint(p) { return this.clone()._multByPoint(p); },\n\n    /**\n     * Divide this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    divByPoint(p) { return this.clone()._divByPoint(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {number} k factor\n     * @return {Point} output point\n     */\n    mult(k) { return this.clone()._mult(k); },\n\n    /**\n     * Divide this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {number} k factor\n     * @return {Point} output point\n     */\n    div(k) { return this.clone()._div(k); },\n\n    /**\n     * Rotate this point around the 0, 0 origin by an angle a,\n     * given in radians\n     * @param {number} a angle to rotate around, in radians\n     * @return {Point} output point\n     */\n    rotate(a) { return this.clone()._rotate(a); },\n\n    /**\n     * Rotate this point around p point by an angle a,\n     * given in radians\n     * @param {number} a angle to rotate around, in radians\n     * @param {Point} p Point to rotate around\n     * @return {Point} output point\n     */\n    rotateAround(a, p) { return this.clone()._rotateAround(a, p); },\n\n    /**\n     * Multiply this point by a 4x1 transformation matrix\n     * @param {[number, number, number, number]} m transformation matrix\n     * @return {Point} output point\n     */\n    matMult(m) { return this.clone()._matMult(m); },\n\n    /**\n     * Calculate this point but as a unit vector from 0, 0, meaning\n     * that the distance from the resulting point to the 0, 0\n     * coordinate will be equal to 1 and the angle from the resulting\n     * point to the 0, 0 coordinate will be the same as before.\n     * @return {Point} unit vector point\n     */\n    unit() { return this.clone()._unit(); },\n\n    /**\n     * Compute a perpendicular point, where the new y coordinate\n     * is the old x coordinate and the new x coordinate is the old y\n     * coordinate multiplied by -1\n     * @return {Point} perpendicular point\n     */\n    perp() { return this.clone()._perp(); },\n\n    /**\n     * Return a version of this point with the x & y coordinates\n     * rounded to integers.\n     * @return {Point} rounded point\n     */\n    round() { return this.clone()._round(); },\n\n    /**\n     * Return the magnitude of this point: this is the Euclidean\n     * distance from the 0, 0 coordinate to this point's x and y\n     * coordinates.\n     * @return {number} magnitude\n     */\n    mag() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n\n    /**\n     * Judge whether this point is equal to another point, returning\n     * true or false.\n     * @param {Point} other the other point\n     * @return {boolean} whether the points are equal\n     */\n    equals(other) {\n        return this.x === other.x &&\n               this.y === other.y;\n    },\n\n    /**\n     * Calculate the distance from this point to another point\n     * @param {Point} p the other point\n     * @return {number} distance\n     */\n    dist(p) {\n        return Math.sqrt(this.distSqr(p));\n    },\n\n    /**\n     * Calculate the distance from this point to another point,\n     * without the square root step. Useful if you're comparing\n     * relative distances.\n     * @param {Point} p the other point\n     * @return {number} distance\n     */\n    distSqr(p) {\n        const dx = p.x - this.x,\n            dy = p.y - this.y;\n        return dx * dx + dy * dy;\n    },\n\n    /**\n     * Get the angle from the 0, 0 coordinate to this point, in radians\n     * coordinates.\n     * @return {number} angle\n     */\n    angle() {\n        return Math.atan2(this.y, this.x);\n    },\n\n    /**\n     * Get the angle from this point to another point, in radians\n     * @param {Point} b the other point\n     * @return {number} angle\n     */\n    angleTo(b) {\n        return Math.atan2(this.y - b.y, this.x - b.x);\n    },\n\n    /**\n     * Get the angle between this point and another point, in radians\n     * @param {Point} b the other point\n     * @return {number} angle\n     */\n    angleWith(b) {\n        return this.angleWithSep(b.x, b.y);\n    },\n\n    /**\n     * Find the angle of the two vectors, solving the formula for\n     * the cross product a x b = |a||b|sin(θ) for θ.\n     * @param {number} x the x-coordinate\n     * @param {number} y the y-coordinate\n     * @return {number} the angle in radians\n     */\n    angleWithSep(x, y) {\n        return Math.atan2(\n            this.x * y - this.y * x,\n            this.x * x + this.y * y);\n    },\n\n    /** @param {[number, number, number, number]} m */\n    _matMult(m) {\n        const x = m[0] * this.x + m[1] * this.y,\n            y = m[2] * this.x + m[3] * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _add(p) {\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _sub(p) {\n        this.x -= p.x;\n        this.y -= p.y;\n        return this;\n    },\n\n    /** @param {number} k */\n    _mult(k) {\n        this.x *= k;\n        this.y *= k;\n        return this;\n    },\n\n    /** @param {number} k */\n    _div(k) {\n        this.x /= k;\n        this.y /= k;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _multByPoint(p) {\n        this.x *= p.x;\n        this.y *= p.y;\n        return this;\n    },\n\n    /** @param {Point} p */\n    _divByPoint(p) {\n        this.x /= p.x;\n        this.y /= p.y;\n        return this;\n    },\n\n    _unit() {\n        this._div(this.mag());\n        return this;\n    },\n\n    _perp() {\n        const y = this.y;\n        this.y = this.x;\n        this.x = -y;\n        return this;\n    },\n\n    /** @param {number} angle */\n    _rotate(angle) {\n        const cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = cos * this.x - sin * this.y,\n            y = sin * this.x + cos * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    /**\n     * @param {number} angle\n     * @param {Point} p\n     */\n    _rotateAround(angle, p) {\n        const cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _round() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        return this;\n    },\n\n    constructor: Point\n};\n\n/**\n * Construct a point from an array if necessary, otherwise if the input\n * is already a Point, return it unchanged.\n * @param {Point | [number, number] | {x: number, y: number}} p input value\n * @return {Point} constructed point.\n * @example\n * // this\n * var point = Point.convert([0, 1]);\n * // is equivalent to\n * var point = new Point(0, 1);\n */\nPoint.convert = function (p) {\n    if (p instanceof Point) {\n        return /** @type {Point} */ (p);\n    }\n    if (Array.isArray(p)) {\n        return new Point(+p[0], +p[1]);\n    }\n    if (p.x !== undefined && p.y !== undefined) {\n        return new Point(+p.x, +p.y);\n    }\n    throw new Error('Expected [x, y] or {x, y} point format');\n};\n", "\nimport Point from '@mapbox/point-geometry';\n\n/** @import Pbf from 'pbf' */\n/** @import {Feature} from 'geojson' */\n\nexport class VectorTileFeature {\n    /**\n     * @param {Pbf} pbf\n     * @param {number} end\n     * @param {number} extent\n     * @param {string[]} keys\n     * @param {unknown[]} values\n     */\n    constructor(pbf, end, extent, keys, values) {\n        // Public\n\n        /** @type {Record<string, unknown>} */\n        this.properties = {};\n\n        this.extent = extent;\n        /** @type {0 | 1 | 2 | 3} */\n        this.type = 0;\n\n        /** @type {number | undefined} */\n        this.id = undefined;\n\n        this._pbf = pbf;\n        this._geometry = -1;\n        this._keys = keys;\n        this._values = values;\n\n        pbf.readFields(readFeature, this, end);\n    }\n\n    loadGeometry() {\n        const pbf = this._pbf;\n        pbf.pos = this._geometry;\n\n        const end = pbf.readVarint() + pbf.pos;\n\n        /** @type Point[][] */\n        const lines = [];\n\n        /** @type Point[] | undefined */\n        let line;\n\n        let cmd = 1;\n        let length = 0;\n        let x = 0;\n        let y = 0;\n\n        while (pbf.pos < end) {\n            if (length <= 0) {\n                const cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n\n            length--;\n\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n\n                if (cmd === 1) { // moveTo\n                    if (line) lines.push(line);\n                    line = [];\n                }\n\n                if (line) line.push(new Point(x, y));\n\n            } else if (cmd === 7) {\n\n                // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n                if (line) {\n                    line.push(line[0].clone()); // closePolygon\n                }\n\n            } else {\n                throw new Error(`unknown command ${cmd}`);\n            }\n        }\n\n        if (line) lines.push(line);\n\n        return lines;\n    }\n\n    bbox() {\n        const pbf = this._pbf;\n        pbf.pos = this._geometry;\n\n        const end = pbf.readVarint() + pbf.pos;\n        let cmd = 1,\n            length = 0,\n            x = 0,\n            y = 0,\n            x1 = Infinity,\n            x2 = -Infinity,\n            y1 = Infinity,\n            y2 = -Infinity;\n\n        while (pbf.pos < end) {\n            if (length <= 0) {\n                const cmdLen = pbf.readVarint();\n                cmd = cmdLen & 0x7;\n                length = cmdLen >> 3;\n            }\n\n            length--;\n\n            if (cmd === 1 || cmd === 2) {\n                x += pbf.readSVarint();\n                y += pbf.readSVarint();\n                if (x < x1) x1 = x;\n                if (x > x2) x2 = x;\n                if (y < y1) y1 = y;\n                if (y > y2) y2 = y;\n\n            } else if (cmd !== 7) {\n                throw new Error(`unknown command ${cmd}`);\n            }\n        }\n\n        return [x1, y1, x2, y2];\n    }\n\n    /**\n     * @param {number} x\n     * @param {number} y\n     * @param {number} z\n     * @return {Feature}\n     */\n    toGeoJSON(x, y, z) {\n        const size = this.extent * Math.pow(2, z),\n            x0 = this.extent * x,\n            y0 = this.extent * y,\n            vtCoords = this.loadGeometry();\n\n        /** @param {Point} p */\n        function projectPoint(p) {\n            return [\n                (p.x + x0) * 360 / size - 180,\n                360 / Math.PI * Math.atan(Math.exp((1 - (p.y + y0) * 2 / size) * Math.PI)) - 90\n            ];\n        }\n\n        /** @param {Point[]} line */\n        function projectLine(line) {\n            return line.map(projectPoint);\n        }\n\n        /** @type {Feature[\"geometry\"]} */\n        let geometry;\n\n        if (this.type === 1) {\n            const points = [];\n            for (const line of vtCoords) {\n                points.push(line[0]);\n            }\n            const coordinates = projectLine(points);\n            geometry = points.length === 1 ?\n                {type: 'Point', coordinates: coordinates[0]} :\n                {type: 'MultiPoint', coordinates};\n\n        } else if (this.type === 2) {\n\n            const coordinates = vtCoords.map(projectLine);\n            geometry = coordinates.length === 1 ?\n                {type: 'LineString', coordinates: coordinates[0]} :\n                {type: 'MultiLineString', coordinates};\n\n        } else if (this.type === 3) {\n            const polygons = classifyRings(vtCoords);\n            const coordinates = [];\n            for (const polygon of polygons) {\n                coordinates.push(polygon.map(projectLine));\n            }\n            geometry = coordinates.length === 1 ?\n                {type: 'Polygon', coordinates: coordinates[0]} :\n                {type: 'MultiPolygon', coordinates};\n        } else {\n\n            throw new Error('unknown feature type');\n        }\n\n        /** @type {Feature} */\n        const result = {\n            type: 'Feature',\n            geometry,\n            properties: this.properties\n        };\n\n        if (this.id != null) {\n            result.id = this.id;\n        }\n\n        return result;\n    }\n}\n\n/** @type {['Unknown', 'Point', 'LineString', 'Polygon']} */\nVectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];\n\n/**\n * @param {number} tag\n * @param {VectorTileFeature} feature\n * @param {Pbf} pbf\n */\nfunction readFeature(tag, feature, pbf) {\n    if (tag === 1) feature.id = pbf.readVarint();\n    else if (tag === 2) readTag(pbf, feature);\n    else if (tag === 3) feature.type = /** @type {0 | 1 | 2 | 3} */ (pbf.readVarint());\n    else if (tag === 4) feature._geometry = pbf.pos;\n}\n\n/**\n * @param {Pbf} pbf\n * @param {VectorTileFeature} feature\n */\nfunction readTag(pbf, feature) {\n    const end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n        const key = feature._keys[pbf.readVarint()],\n            value = feature._values[pbf.readVarint()];\n        feature.properties[key] = value;\n    }\n}\n\n/** classifies an array of rings into polygons with outer rings and holes\n * @param {Point[][]} rings\n */\nexport function classifyRings(rings) {\n    const len = rings.length;\n\n    if (len <= 1) return [rings];\n\n    const polygons = [];\n    let polygon, ccw;\n\n    for (let i = 0; i < len; i++) {\n        const area = signedArea(rings[i]);\n        if (area === 0) continue;\n\n        if (ccw === undefined) ccw = area < 0;\n\n        if (ccw === area < 0) {\n            if (polygon) polygons.push(polygon);\n            polygon = [rings[i]];\n\n        } else if (polygon) {\n            polygon.push(rings[i]);\n        }\n    }\n    if (polygon) polygons.push(polygon);\n\n    return polygons;\n}\n\n/** @param {Point[]} ring */\nfunction signedArea(ring) {\n    let sum = 0;\n    for (let i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2.x - p1.x) * (p1.y + p2.y);\n    }\n    return sum;\n}\n\nexport class VectorTileLayer {\n    /**\n     * @param {Pbf} pbf\n     * @param {number} [end]\n     */\n    constructor(pbf, end) {\n        // Public\n        this.version = 1;\n        this.name = '';\n        this.extent = 4096;\n        this.length = 0;\n\n        // Private\n        this._pbf = pbf;\n\n        /** @type {string[]} */\n        this._keys = [];\n\n        /** @type {unknown[]} */\n        this._values = [];\n\n        /** @type {number[]} */\n        this._features = [];\n\n        pbf.readFields(readLayer, this, end);\n\n        this.length = this._features.length;\n    }\n\n    /** return feature `i` from this layer as a `VectorTileFeature`\n     * @param {number} i\n     */\n    feature(i) {\n        if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');\n\n        this._pbf.pos = this._features[i];\n\n        const end = this._pbf.readVarint() + this._pbf.pos;\n        return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);\n    }\n}\n\n/**\n * @param {number} tag\n * @param {VectorTileLayer} layer\n * @param {Pbf} pbf\n */\nfunction readLayer(tag, layer, pbf) {\n    if (tag === 15) layer.version = pbf.readVarint();\n    else if (tag === 1) layer.name = pbf.readString();\n    else if (tag === 5) layer.extent = pbf.readVarint();\n    else if (tag === 2) layer._features.push(pbf.pos);\n    else if (tag === 3) layer._keys.push(pbf.readString());\n    else if (tag === 4) layer._values.push(readValueMessage(pbf));\n}\n\n/**\n * @param {Pbf} pbf\n */\nfunction readValueMessage(pbf) {\n    let value = null;\n    const end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n        const tag = pbf.readVarint() >> 3;\n\n        value = tag === 1 ? pbf.readString() :\n            tag === 2 ? pbf.readFloat() :\n            tag === 3 ? pbf.readDouble() :\n            tag === 4 ? pbf.readVarint64() :\n            tag === 5 ? pbf.readVarint() :\n            tag === 6 ? pbf.readSVarint() :\n            tag === 7 ? pbf.readBoolean() : null;\n    }\n\n    return value;\n}\n\nexport class VectorTile {\n    /**\n     * @param {Pbf} pbf\n     * @param {number} [end]\n     */\n    constructor(pbf, end) {\n        /** @type {Record<string, VectorTileLayer>} */\n        this.layers = pbf.readFields(readTile, {}, end);\n    }\n}\n\n/**\n * @param {number} tag\n * @param {Record<string, VectorTileLayer>} layers\n * @param {Pbf} pbf\n */\nfunction readTile(tag, layers, pbf) {\n    if (tag === 3) {\n        const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);\n        if (layer.length) layers[layer.name] = layer;\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
